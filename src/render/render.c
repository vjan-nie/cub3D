/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vjan-nie <vjan-nie@student.42madrid.com    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/23 16:43:45 by vjan-nie          #+#    #+#             */
/*   Updated: 2025/12/04 09:56:57 by vjan-nie         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "cub3d.h"

/**
* @brief dsf.
* @param dst Destiny: pointer to the adress where the color bytes are stored, 
* in the image framebuffer structure (specifically in img-data).
* Calculation:
* y * img->line_len: Bytes needed to skip to reach current line.
* x * (img->bpp / 8): Bytes needed to skip to reach the current 'x' pixel.
* img->data + (...): 
*	We add this current pixel position to the begining of
*	the framebuffer: destiny.
* 
* Each color component is written byte by byte:
* (endian: Byte order (0: little-endian/0xRRGGBB format)
* dst[0] → Blue
* dst[1] → Green
* dst[2] → Red
* dst[3] → Alpha (transparency level, if given)
* 
* Color byte storing: 
* '>>' to shift the bits according to the position we're looking for,
* '& 0xFF' to keep only the last 8 bits.
*/
void	put_pixel(t_img *img, int x, int y, int color)
{
	char	*dst;

	if (x < 0 || x >= img->width || y < 0 || y >= img->height)
		return ;
	dst = img->data + (y * img->line_len + x * (img->bpp / 8));
	dst[0] = color & 0xFF;
	dst[1] = (color >> 8) & 0xFF;
	dst[2] = (color >> 16) & 0xFF;
	if (img->bpp == 32)
		dst[3] = (color >> 24) & 0xFF;
}

/**
 * @brief Draws a full horizontal line with the corresponding color
 * (ceiling or floor).
 */
static void	fill_line(t_img *img, int y, int color)
{
	int	x;

	x = 0;
	while (x < img->width)
	{
		put_pixel(img, x, y, color);
		x++;
	}
}

/**
 * @brief Draws the background split in two horizontal parts:
 * ceiling first(upper side) and floor, which have their color 
 * assigned in the map file.
 */
static void	draw_background(t_cub3d *cub)
{
	int	y;
	int	half;

	y = 0;
	half = cub->screen_height / 2;
	while (y < half)
	{
		fill_line(&cub->frame, y, cub->map.ceiling_color);
		y++;
	}
	while (y < cub->screen_height)
	{
		fill_line(&cub->frame, y, cub->map.floor_color);
		y++;
	}
}

/**
 * @brief Initiates the structure which serves as a "framebuffer",
 * using MLX's tool fot that purpose: mlx_new_image(). 
 * Each frame will be "pre-drawn" before being loaded 
 * as a whole in the window.
 * @note We also retrieve the pointer to the dataset generated by MLX,
 * using mlx_get_data_addr(), which allows direct manipulation.
 */
void	create_frame(t_cub3d *cub, t_img *img)
{
	img->width = cub->screen_width;
	img->height = cub->screen_height;
	img->img_ptr = mlx_new_image(cub->mlx, img->width, img->height);
	if (!img->img_ptr)
		return ;
	img->data = mlx_get_data_addr(img->img_ptr, \
			&img->bpp, &img->line_len, &img->endian);
}

/**
 * @brief Main rendering function: we first draw the background,
 * then we use raycasting to draw the walls.
 */
void	render_frame(t_cub3d *cub)
{
	draw_background(cub);
	raycast(cub);
}
